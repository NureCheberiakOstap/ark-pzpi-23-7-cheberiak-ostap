Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії



Звіт
з лабораторної роботи №2
з дисципліни «Аналіз та рефакторінг коду»





 
Виконав:
ст. гр. ПЗПІ 23-7
Чеберяк Остап Ігорович
                   
                                                                       









Харків 2026
1.	Будова та архітектура програмної системи
У цій роботі розробляється серверна частина програмної системи для організації спортивних змагань, яка забезпечує централізоване збереження даних, реалізацію бізнес-логіки та надання доступу клієнтським застосункам через програмний інтерфейс.
Програмна система реалізована у вигляді вебзастосунку з клієнт–серверною архітектурою, що відповідає сучасним підходам до побудови розподілених інформаційних систем. Такий підхід дозволяє відокремити клієнтську частину від серверної, забезпечити масштабованість, зручність супроводу та повторне використання серверних компонентів.

1.1	Загальна архітектура системи
1.	Клієнтська частина
Клієнтська частина представлена вебінтерфейсом, який працює у браузері користувача. Вона забезпечує взаємодію з сервером шляхом надсилання HTTP-запитів до REST API. У межах даної лабораторної роботи клієнтська частина безпосередньо не реалізується, а її функції імітуються за допомогою інструменту Swagger UI.

2.	Серверна частина (Backend)
Серверна частина реалізована з використанням платформи ASP.NET Core Web API. Вона відповідає за:
•	обробку HTTP-запитів;
•	реалізацію бізнес-логіки системи;
•	контроль доступу користувачів відповідно до ролей;
•	взаємодію з базою даних через ORM.
Сервер надає REST-інтерфейс для виконання операцій з користувачами, турнірами, командами та заявками на участь у змаганнях.


3.	База даних
Для збереження інформації використовується реляційна база даних SQL Server. У базі даних зберігаються відомості про користувачів, ролі, турніри, команди, заявки на участь та інші сутності предметної області.

1.2	Серверна частина та її компоненти
Серверна частина програмної системи побудована за багаторівневою архітектурою та включає такі основні компоненти:

•	Контролери (Controllers)
Контролери реалізують REST API та приймають HTTP-запити від клієнтів. Кожен контролер відповідає за окрему групу функцій, зокрема:
o	автентифікацію користувачів;
o	керування турнірами;
o	керування командами;
o	обробку заявок на участь.

•	Сутності (Entities)
	Сутності відображають основні об’єкти предметної області (користувач, роль, турнір, команда, заявка) та використовуються для роботи з базою даних.

•	Контекст бази даних (DbContext)
	Для доступу до бази даних використовується Entity Framework Core. Контекст бази даних забезпечує виконання CRUD-операцій та керування зв’язками між сутностями.

•	Механізм контролю доступу
	У системі реалізовано спрощений механізм автентифікації на основі токенів, що передаються в HTTP-заголовках. Контроль доступу до серверних операцій здійснюється відповідно до ролей користувачів (Organizer, Participant тощо).

1.3	Технологічний стек
У процесі розробки серверної частини програмної системи використано такі технології:
•	ASP.NET Core Web API – для реалізації серверної логіки та REST API;
•	Entity Framework Core – для роботи з базою даних на основі ORM-підходу;
•	Microsoft SQL Server – як система керування реляційною базою даних;
•	Swagger (OpenAPI) – для документування та тестування REST API.
Використання зазначеного технологічного стеку дозволяє створити надійну, розширювану та зручну у використанні серверну частину програмної системи.
 
2.	UML-діаграма прецедентів серверної частини
У межах цієї роботи для серверної частини програмної системи було побудовано UML-діаграму прецедентів (Use Case Diagram). Дана діаграма використовується для наочного відображення взаємодії користувачів з серверною частиною системи та визначення основних функціональних можливостей, які надаються різним ролям.
UML-діаграма прецедентів дозволяє:
•	визначити коло користувачів системи;
•	встановити їх ролі та права доступу;
•	описати основні сценарії використання серверних функцій;
•	забезпечити наочне уявлення про функціональну структуру системи.

2.1	Актори системи
У серверній частині програмної системи для організації спортивних змагань виділено такі актори:
1.	Organizer (Організатор)
	Користувач, який відповідає за створення та адміністрування спортивних змагань. Організатор має розширені права доступу до функціоналу системи.
2.	Participant (Учасник)
	Користувач, який бере участь у змаганнях. Він може створювати команди та подавати заявки на участь у турнірах.
3.	Judge (Суддя)
	Користувач, який вносить результати матчів та контролює перебіг змагань.
4.	Viewer (Глядач)
	Користувач, який має доступ лише до перегляду інформації про турніри та результати.
У межах даної лабораторної роботи основна увага зосереджена на ролях Organizer та Participant, оскільки саме вони реалізовані в серверній частині системи.

2.2	Прецеденти використання
Для серверної частини програмної системи виділено такі основні прецеденти використання:
	Для ролі Organizer:
•	реєстрація та авторизація в системі;
•	створення нового турніру;
•	публікація турніру;
•	перегляд списку заявок на участь;
•	підтвердження або відхилення заявок учасників.
	Для ролі Participant:
•	реєстрація та авторизація в системі;
•	створення команди;
•	подання заявки на участь у турнірі;
•	перегляд інформації про турніри та статус поданих заявок.
	Для ролі Judge (перспектива розвитку):
•	перегляд списку матчів;
•	внесення результатів матчів;
•	редагування результатів змагань.

2.3	Опис UML-діаграми прецедентів
На UML-діаграмі (рис. 1) прецедентів серверної частини зображено взаємодію акторів із відповідними функціями системи. Кожен прецедент представлений у вигляді окремого овала, що відповідає конкретній серверній операції, реалізованій через REST API.
 
Рисунок 2.1 – UML-діаграма прецедентів

Зв’язки між акторами та прецедентами відображають, які саме ролі мають доступ до певних функцій системи. Таким чином, діаграма наочно демонструє контроль доступу до серверних операцій відповідно до ролей користувачів.
 
3.	ER-діаграма та структура бази даних
Для збереження інформації та забезпечення коректної роботи серверної частини програмної системи використовується реляційна база даних. Структура бази даних спроєктована з урахуванням основних об’єктів предметної області та зв’язків між ними.
ER-діаграма відображає логічну модель даних і демонструє таблиці, їх атрибути, первинні та зовнішні ключі, а також типи зв’язків між таблицями.

3.1	Основні таблиці бази даних
Таблиця Roles
Таблиця призначена для зберігання ролей користувачів системи.
Кожна таблиця користувачів має посилання на відповідну роль.
Основні поля:
•	Id – первинний ключ;
•	Name – назва ролі (Organizer, Participant тощо).

Таблиця Users
Таблиця містить облікові дані користувачів системи.
Основні поля:
•	Id – первинний ключ;
•	Name – ім’я користувача;
•	Email – електронна адреса;
•	PasswordHash – хеш пароля;
•	RoleId – зовнішній ключ на таблицю Roles;
•	CreatedAt – дата створення облікового запису;
•	IsActive – статус активності користувача.

Таблиця Tournaments
Таблиця використовується для зберігання інформації про спортивні турніри.
Основні поля:
•	Id – первинний ключ;
•	Title – назва турніру;
•	SportType – вид спорту;
•	Format – формат проведення;
•	StartDate, EndDate – дати проведення;
•	Status – поточний стан турніру;
•	OrganizerUserId – зовнішній ключ на користувача-організатора;
•	CreatedAt – дата створення запису.

Таблиця Teams
Таблиця призначена для зберігання інформації про команди учасників.
Основні поля:
•	Id – первинний ключ;
•	Name – назва команди;
•	CaptainUserId – зовнішній ключ на користувача-капітана;
•	CreatedAt – дата створення команди.

Таблиця TournamentRegistrations
Таблиця реалізує зв’язок між командами та турнірами та використовується для збереження заявок на участь.
Основні поля:
•	Id – первинний ключ;
•	TournamentId – зовнішній ключ на таблицю Tournaments;
•	TeamId – зовнішній ключ на таблицю Teams;
•	ApplicantUserId – користувач, який подав заявку;
•	Status – статус заявки;
•	CreatedAt – дата подання заявки.

3.2	ER-діаграма бази даних
Для проєктування структури бази даних програмної системи була побудована ER-діаграма, яка відображає основні сутності предметної області, їх атрибути, первинні та зовнішні ключі, а також зв’язки між таблицями з відповідними кардинальностями.
ER-діаграма дозволяє наочно представити логічну модель даних і демонструє взаємозв’язок між користувачами, ролями, турнірами, командами та заявками на участь у змаганнях. Такий підхід забезпечує цілісність даних і спрощує подальшу реалізацію серверної логіки.

 
Рисунок 2.2 – ER-діаграма бази даних програмної системи для організації спортивних змагань

ER-діаграма відображає логічну структуру бази даних програмної системи та демонструє коректне використання первинних і зовнішніх ключів, а також реляційних зв’язків між сутностями. Запропонована модель забезпечує масштабованість системи та створює основу для реалізації бізнес-логіки серверної частини.

 
Рисунок 2.3 – Схема бази даних у SQL Server Management Studio

3.3	Зв’язки між таблицями
На ER-діаграмі реалізовано такі основні зв’язки між таблицями:
•	між таблицями Roles і Users встановлено зв’язок типу один до багатьох, що дозволяє призначати кожному користувачу певну роль у системі;
•	між таблицями Users і Teams реалізовано зв’язок один до багатьох, де користувач виступає у ролі капітана команди;
•	між таблицями Users і Tournaments встановлено зв’язок один до багатьох, який відображає роль користувача як організатора турніру;
•	між таблицями Tournaments і TournamentRegistrations реалізовано зв’язок один до багатьох, що забезпечує зберігання заявок команд на участь у турнірі;
•	між таблицями Teams і TournamentRegistrations встановлено зв’язок один до багатьох, що дозволяє команді брати участь у різних турнірах;
•	таблиця TournamentRegistrations використовується для реалізації зв’язку багато до багатьох між таблицями Tournaments і Teams, що відповідає вимогам реляційного моделювання.
Окремо на ER-діаграмі передбачені таблиці Matches та MatchResults, які описують логіку проведення матчів та збереження результатів змагань. Дані таблиці пов’язані з турнірами, командами та користувачами і призначені для подальшого розширення функціональних можливостей системи.
 
4.	Використання ORM та робота з базою даних
Для взаємодії серверної частини програмної системи з реляційною базою даних використовується технологія Object-Relational Mapping (ORM). Застосування ORM дозволяє працювати з базою даних за допомогою об’єктної моделі, мінімізувати використання ручних SQL-запитів та забезпечити цілісність даних на рівні прикладної логіки.
У даному проєкті для реалізації ORM використано Entity Framework Core, який інтегрований у платформу ASP.NET Core та забезпечує зручні засоби для доступу до даних, управління зв’язками між сутностями та автоматичного створення структури бази даних.

4.1	Контекст бази даних
Центральним елементом роботи з базою даних є контекст даних, який представлений класом ApplicationDbContext. Даний клас наслідується від DbContext і містить набори сутностей (DbSet<T>), що відповідають таблицям бази даних.
Контекст бази даних виконує такі функції:
•	забезпечує доступ до таблиць бази даних;
•	керує зв’язками між сутностями;
•	дозволяє виконувати CRUD-операції;
•	відповідає за застосування міграцій.

 
Рисунок 2.4 – Опис контексту бази даних ApplicationDbContext

4.2	Відображення сутностей на таблиці бази даних
Кожна сутність предметної області представлена у вигляді окремого класу, який відповідає таблиці в базі даних. Наприклад, сутності User, Tournament, Team та TournamentRegistration відображаються на однойменні таблиці за допомогою Entity Framework Core.
Зв’язки між таблицями реалізуються через навігаційні властивості та зовнішні ключі, що дозволяє автоматично підтримувати цілісність даних. Типи зв’язків (один до багатьох, багато до багатьох) відповідають структурі, представленій на ER-діаграмі.

4.3	Міграції та ініціалізація бази даних
Для створення та оновлення структури бази даних використовується механізм міграцій Entity Framework Core. Міграції дозволяють автоматично створювати таблиці, зовнішні ключі та індекси відповідно до визначених сутностей.
 
Рисунок 2.5 – Структура таблиць бази даних

Під час запуску серверної частини застосовується автоматичне виконання міграцій, що забезпечує актуальність структури бази даних без необхідності ручного втручання. Крім того, передбачено початкове наповнення таблиці ролей базовими значеннями, необхідними для роботи системи.

4.4	Переваги використання ORM
Використання Entity Framework Core у даному проєкті забезпечує такі переваги:
•	спрощення доступу до бази даних;
•	зменшення кількості помилок при роботі з даними;
•	автоматичне управління зв’язками між таблицями;
•	підвищення читабельності та підтримуваності коду;
•	можливість швидкого розширення структури бази даних у майбутньому.
	Якщо говорити коротко, то застосування ORM у вигляді Entity Framework Core дозволяє ефективно організувати роботу з реляційною базою даних та інтегрувати її з серверною частиною програмної системи. Використання контексту даних, сутностей і міграцій створює надійну основу для реалізації бізнес-логіки та подальшого розвитку системи.
 
5.	Специфікація та реалізація REST API
	Серверна частина програмної системи надає доступ до функціональних можливостей через REST API, яке реалізує взаємодію між клієнтськими застосунками та сервером за допомогою HTTP-протоколу. REST API забезпечує стандартизований обмін даними у форматі JSON та підтримує основні HTTP-методи для виконання операцій над ресурсами системи.
	API побудоване з урахуванням принципів REST, що забезпечує простоту використання, масштабованість та зрозумілу структуру запитів і відповідей.

5.1	Загальні принципи роботи REST API
	REST API серверної частини має такі характеристики:
•	використання HTTP-методів GET, POST, PUT, DELETE;
•	передача даних у форматі JSON;
•	логічна маршрутизація запитів за допомогою URL;
•	використання кодів HTTP-відповідей для інформування клієнта про результат виконання запиту;
•	розмежування доступу до ресурсів відповідно до ролей користувачів.
	Для автентифікації використовується токен, який передається клієнтом у заголовку HTTP-запиту. Сервер перевіряє токен та роль користувача перед виконанням захищених операцій.

5.2	Контролери серверної частини
	Функціональність REST API реалізована за допомогою контролерів, кожен з яких відповідає за окрему групу ресурсів.
	AuthController
	Контролер відповідає за автентифікацію та реєстрацію користувачів у системі.
	Основні можливості:
•	реєстрація нового користувача;
•	авторизація користувача та отримання токена доступу.

	TournamentsController
	Контролер призначений для керування турнірами.
	Основні можливості:
•	створення нового турніру;
•	публікація турніру;
•	отримання списку турнірів;
•	отримання інформації про конкретний турнір.
	Доступ до створення та керування турнірами обмежений роллю Organizer.

	TeamsController
	Контролер відповідає за керування командами учасників.
	Основні можливості:
•	створення команди;
•	отримання списку команд;
•	отримання інформації про конкретну команду.
	Створення команд доступне користувачам з роллю Participant або Organizer.

	RegistrationController
	Контролер використовується для керування заявками команд на участь у турнірах.
	Основні можливості:
•	подання заявки на участь у турнірі;
•	перегляд заявок;
•	підтвердження або відхилення заявок організатором.

5.3	Основні REST API endpoints
HTTP-запит	Endpoints	Роль	Опис
POST	/api/auth/register	-	Реєстрація користувача
POST	/api/auth/login	-	
Авторизація користувача

POST	/api/tournaments	Organizer	Створення турніру
POST	/api/tournaments/{id}/publish	Organizer	
Публікація турніру

GET	/api/tournaments	-	Отримання списку турнірів
POST					/api/teams	Participant, Organizer	
Створення команди

GET	/api/teams	-	
Отримання списку команд

POST	/api/registrations	Participant	Подання заявки
POST	/api/registrations/{id}/approve	Organizer	
Підтвердження заявки

Таблиця 2.1 – Основні endpoint-и серверної частини

5.4	Контроль доступу та обробки помилок
	Для захисту серверних операцій реалізовано механізм перевірки ролей користувачів. Перед виконанням кожного захищеного endpoint’у перевіряється автентичність користувача та його права доступу.
	У разі помилок сервер повертає відповідні HTTP-коди:
•	200 OK – успішне виконання запиту;
•	201 Created – ресурс успішно створено;
•	400 Bad Request – некоректні вхідні дані;
•	401 Unauthorized – відсутня або некоректна автентифікація;
•	403 Forbidden – відсутні права доступу;
•	404 Not Found – ресурс не знайдено.
 
6.	Тестування REST API серверної частини
Для перевірки коректності роботи серверної частини програмної системи було виконано тестування REST API. Тестування проводилось з використанням інструменту Swagger UI, який дозволяє надсилати HTTP-запити до серверу та аналізувати отримані відповіді.
У процесі тестування перевірялась:
•	коректність обробки HTTP-запитів;
•	правильність передачі та обробки даних у форматі JSON;
•	контроль доступу до серверних операцій;
•	відповідність відповідей сервера очікуваним HTTP-кодам.

6.1	Реєстрація користувача
На першому етапі тестування було перевірено роботу endpoint’у реєстрації користувачів. Для цього було виконано POST-запит із передачею облікових даних користувача та ролі.
Сервер успішно обробив запит та повернув відповідь з кодом 200 OK, що підтверджує коректність створення нового користувача в системі.


 
Рисунок 2.6 – Реєстрація користувача з роллю Organizer через REST API

6.2	Авторизація користувача
На наступному етапі було перевірено роботу endpoint’у авторизації користувачів. Після надсилання коректних облікових даних сервер повернув токен доступу, який використовується для виконання захищених операцій.
Отриманий токен передається у заголовках HTTP-запитів та використовується для перевірки прав доступу користувача.

 
Рисунок 2.7 – Авторизація користувача

6.3	Створення турніру
Після успішної авторизації було перевірено можливість створення нового турніру користувачем з роллю Organizer. Для цього було виконано POST-запит із передачею даних турніру.

 
Рисунок 2.8 – Створення нового турніру

6.4	Створення команди
На даному етапі було перевірено створення команди користувачем з роллю Participant.

 
Рисунок 2.9 – Створення команди в Swagger UI
6.5	Аналіз помилок під час тестування API
Під час тестування деяких endpoint’ів було зафіксовано типові помилки валідації та авторизації, що підтверджує наявність механізмів контролю доступу і перевірки вхідних даних на серверній стороні.
Помилка 401 Unauthorized виникає у випадку відсутності токена автентифікації. Для захищених операцій сервер очікує заголовок X-Auth-Token. Якщо даний заголовок не передано, сервер повертає код 401 та повідомлення X-Auth-Token header is required.. Це означає, що доступ до операції обмежено для неавторизованих запитів, а клієнт повинен виконати авторизацію та передати токен у заголовках запиту.
 
ДОДАТОК А

Таблиця ролей:
CREATE TABLE dbo.Roles
(
    Id   INT IDENTITY(1,1) NOT NULL CONSTRAINT PK_Roles PRIMARY KEY,
    Name NVARCHAR(50) NOT NULL
);

Таблиця користувачів:
CREATE TABLE dbo.Users
(
    Id           UNIQUEIDENTIFIER NOT NULL CONSTRAINT PK_Users PRIMARY KEY,
    Name         NVARCHAR(120) NOT NULL,
    Email        NVARCHAR(200) NOT NULL,
    PasswordHash NVARCHAR(300) NOT NULL,
    RoleId       INT NOT NULL,
    CreatedAt    DATETIME2 NOT NULL CONSTRAINT DF_Users_CreatedAt DEFAULT SYSUTCDATETIME(),
    IsActive     BIT NOT NULL CONSTRAINT DF_Users_IsActive DEFAULT (1),

    CONSTRAINT FK_Users_Roles
        FOREIGN KEY (RoleId) REFERENCES dbo.Roles(Id)
);

Таблиця турнірів:
CREATE TABLE dbo.Tournaments
(
    Id              UNIQUEIDENTIFIER NOT NULL CONSTRAINT PK_Tournaments PRIMARY KEY,
    Title           NVARCHAR(200) NOT NULL,
    SportType       NVARCHAR(50) NOT NULL,
    Format          NVARCHAR(50) NOT NULL,
    StartDate       DATETIME2 NOT NULL,
    EndDate         DATETIME2 NULL,
    Status          NVARCHAR(30) NOT NULL,
    OrganizerUserId UNIQUEIDENTIFIER NOT NULL,
    CreatedAt       DATETIME2 NOT NULL CONSTRAINT DF_Tournaments_CreatedAt DEFAULT SYSUTCDATETIME(),

    CONSTRAINT FK_Tournaments_Users_Organizer
        FOREIGN KEY (OrganizerUserId) REFERENCES dbo.Users(Id)
);

Таблиця команд:
CREATE TABLE dbo.Teams
(
    Id            UNIQUEIDENTIFIER NOT NULL CONSTRAINT PK_Teams PRIMARY KEY,
    Name          NVARCHAR(200) NOT NULL,
    CaptainUserId UNIQUEIDENTIFIER NOT NULL,
    CreatedAt     DATETIME2 NOT NULL CONSTRAINT DF_Teams_CreatedAt DEFAULT SYSUTCDATETIME(),

    CONSTRAINT FK_Teams_Users_Captain
        FOREIGN KEY (CaptainUserId) REFERENCES dbo.Users(Id)
);

Таблиця реєстрації турнірів:
CREATE TABLE dbo.TournamentRegistrations
(
    Id              UNIQUEIDENTIFIER NOT NULL CONSTRAINT PK_TournamentRegistrations PRIMARY KEY,
    TournamentId    UNIQUEIDENTIFIER NOT NULL,
    TeamId          UNIQUEIDENTIFIER NOT NULL,
    ApplicantUserId UNIQUEIDENTIFIER NOT NULL,
    Status          NVARCHAR(20) NOT NULL,
    CreatedAt       DATETIME2 NOT NULL CONSTRAINT DF_Registrations_CreatedAt DEFAULT SYSUTCDATETIME(),

    CONSTRAINT FK_Registrations_Tournaments
        FOREIGN KEY (TournamentId) REFERENCES dbo.Tournaments(Id),

    CONSTRAINT FK_Registrations_Teams
        FOREIGN KEY (TeamId) REFERENCES dbo.Teams(Id),

    CONSTRAINT FK_Registrations_Users_Applicant
        FOREIGN KEY (ApplicantUserId) REFERENCES dbo.Users(Id)
);
Таблиця матчів:
CREATE TABLE dbo.Matches
(
    Id           UNIQUEIDENTIFIER NOT NULL CONSTRAINT PK_Matches PRIMARY KEY,
    TournamentId UNIQUEIDENTIFIER NOT NULL,
    Round        INT NOT NULL,
    HomeTeamId   UNIQUEIDENTIFIER NOT NULL,
    AwayTeamId   UNIQUEIDENTIFIER NOT NULL,
    ScheduledAt  DATETIME2 NOT NULL,
    Location     NVARCHAR(200) NULL,
    Status       NVARCHAR(20) NOT NULL,

    CONSTRAINT FK_Matches_Tournaments
        FOREIGN KEY (TournamentId) REFERENCES dbo.Tournaments(Id),

    CONSTRAINT FK_Matches_Teams_Home
        FOREIGN KEY (HomeTeamId) REFERENCES dbo.Teams(Id),

    CONSTRAINT FK_Matches_Teams_Away
        FOREIGN KEY (AwayTeamId) REFERENCES dbo.Teams(Id)
);

Таблиця результатів матчів:
CREATE TABLE dbo.MatchResults
(
    MatchId         UNIQUEIDENTIFIER NOT NULL CONSTRAINT PK_MatchResults PRIMARY KEY,
    HomeScore       INT NOT NULL,
    AwayScore       INT NOT NULL,
    WinnerTeamId    UNIQUEIDENTIFIER NULL,
    EnteredByUserId UNIQUEIDENTIFIER NOT NULL,
    EnteredAt       DATETIME2 NOT NULL CONSTRAINT DF_MatchResults_EnteredAt DEFAULT SYSUTCDATETIME(),

    CONSTRAINT FK_MatchResults_Matches
        FOREIGN KEY (MatchId) REFERENCES dbo.Matches(Id)
        ON DELETE CASCADE,

    CONSTRAINT FK_MatchResults_Teams_Winner
        FOREIGN KEY (WinnerTeamId) REFERENCES dbo.Teams(Id),

    CONSTRAINT FK_MatchResults_Users_EnteredBy
        FOREIGN KEY (EnteredByUserId) REFERENCES dbo.Users(Id)
);
