Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії



Звіт
з практичної роботи №2
з дисципліни «Аналіз та рефакторінг коду»





 
Виконав:                                                             	Перевірив:
ст. гр. ПЗПІ 23-7                                                	Старший викладач кафедри ПІ
Чеберяк Остап Ігорович                                   	Сокорчук І.П.
                   
                                                                       










Харків 2025

Мета роботи:
Ознайомитись з основними методами рефакторингу, описаними у книзі Мартіна Фаулера, і вибрати три методи, які найкраще підійдуть для рефакторингу коду з практичних або лабораторних робіт.

Об’єкт дослідження:
	Консольний клієнт-серверний чат, що складається з модулів chat, client, server, shutdown.

Хід роботи
1.	Вступ до розділу
У межах практичної роботи було виконано аналіз вихідного коду консольного чат застосунку та визначено ділянки, що потребують покращення. Для рефакторингу було обрано три методи з книги Мартіна Фаулера: Extract Method, Extract Class, Remove Dead Code.
Нижче буде наведено приклади рефакторингу з реального коду проєкту.

2.	Метод 1 – Extract Method
2.1	Опис проблеми
У вихідному коді деякі методи були надмірно великими та містили змішану логіку:
•	роботу з мережею,
•	обробку команд,
•	взаємодію з користувачем,
•	логування.
Це ускладнювало читання, тестування та подальшу підтримку.
Типова проблема: метод main() у ClientMain містив понад 150 рядків коду.

 
2.2	Суть методу Extract Method
Метод Extract Method полягає у винесенні логічно завершених фрагментів коду в окремі методи з чіткими назвами. Це зменшує складність основного методу та підвищує читабельність програми.

2.3	Реалізація
У процесі рефакторингу логіку було розділено на окремі методи:
•	handleClientAuth()
•	handleClientMessages()
•	handleChat()
•	handleShutdown()
Метод run() після рефакторингу виконує лише вибір сценарію роботи клієнта та делегує обробку відповідним методам.

2.4	Результат
Код став більш структурованим, зменшився розмір методу run(), а логіка обробки клієнта стала зрозумілою та легкою для модифікації.

 
 
Рисунки 2.1-2.2 – Код до рефакторингу

 
Рисунок 2.3-2.4 – Код після рефакторингу

3.	Метод 2 – Extract Class
3.1	Опис проблеми
У початковій версії проєкту клас ChatMain відповідав одразу за кілька різних сценаріїв роботи: клієнт, чат-спостерігач та завершення роботи серверу. Це порушувало принцип єдиної відповідальності.

3.2	Суть методу Extract Method
Метод Extract Class передбачає винесення різних ролей або сценаріїв у окремі класи, кожен з яких виконує лише одну функцію.

3.3	Реалізація
Після рефакторингу було створено окремі класи:
•	ChatMain – підключення до сервера як чат-спостерігач;
•	ClientMain – клієнт з автентифікацією та надсиланням повідомлень;
•	ShutdownMain – відправка команди завершення роботи серверу.
Кожен клас має власну точку входу та не містить зайвої логіки.

3.4	Результат
Проєкт став модульним, зменшилась кількість умовних операторів, спростилось тестування та демонстрація роботи програми.

 
 
 
Рисунки 2.5-2.7 – Код до рефакторингу (клас ChatMain)

 
Рисунок 2.8 – Код після рефакторингу (клас ChatMain)

 
 
 
Рисунки 2.9-2.11 – Код після рефакторингу (клас ClientMain)

 
Рисунок 2.12 – Код після рефакторингу (клас ShutdownMain)

4.	Метод 2 – Remove Dead Code
4.1	Опис проблеми
У початковому коді були присутні зайві або неефективні фрагменти: порожні гілки else, дубльовані умовні оператори та перевірки, що не впливали на поведінку програми.

4.2	Суть методу Remove Dead Code
Метод Remove Dead Code полягає у видаленні коду, який не використовується або не має впливу на результат виконання програми.

4.3	Реалізація
Під час рефакторингу було видалено:
•	порожні умовні блоки в ClientMain;
•	дубльовану логіку в ShutdownMain;
•	зайві умовні перевірки в ServerMain.

 
4.4	Результат
Код став компактнішим, читабельнішим і менш схильним до помилок.

 
Рисунок 2.13 – Код до рефакторингу (клас ClientMain (порожній else))

 
Рисунок 2.14 – Код до рефакторингу (клас ShutdownMain (дублювання логіки))

 
Рисунок 2.15 – Код до рефакторингу (клас ServerMain (зайві умовні перевірки))

 
 
 
Рисунки 2.16-2.18 – Коди після рефакторингу

Висновок
У ході виконання практичної роботи №2 було проаналізовано вихідний код консольного клієнт-серверного чат-застосунку та виявлено основні проблеми, пов’язані з надмірною складністю методів, порушенням принципу єдиної відповідальності та наявністю зайвого коду.
Для покращення якості програмного коду було застосовано три методи рефакторингу, описані у книзі Мартіна Фаулера: Extract Method, Extract Class та Remove Dead Code. У результаті рефакторингу код було структуровано, логіку розділено на окремі методи та класи, а також видалено дубльовані та неефективні фрагменти.
Застосування обраних методів дозволило підвищити читабельність, зрозумілість і підтримуваність програмного коду без зміни його функціональної поведінки. Проведена перевірка підтвердила коректну роботу чат-застосунку після рефакторингу.
Отримані навички аналізу та рефакторингу коду є важливими для подальшої професійної діяльності в галузі програмної інженерії та сприяють написанню якісного й надійного програмного забезпечення.

Використані джерела:
1.	Catalog of Refactorings. Refactoring. URL: https://refactoring.com/catalog/ (date of access: 05.02.2026).
2.	The Java™ Tutorials. Moved. URL: https://docs.oracle.com/javase/tutorial/ (date of access: 05.02.2026).
3.	Refactoring: Improving the Design of Existing Code. Addision-Wesley, 2018. 448 p.
4.	GitHub - ryanmcdermott/clean-code-javascript: Clean Code concepts adapted for JavaScript. GitHub. URL: https://github.com/ryanmcdermott/clean-code-javascript (date of access: 07.02.2026).
5.	Martin R. Clean Code: A Handbook of Agile Software Craftsmanship. Pearson Education Canada, 2008.

Посилання на GitHub:
https://github.com/Ostap2006/console-chat-refactoring

Посилання на відео: https://youtu.be/Ui_tD0bBKq0

Презентація:

 
Рисунок 2.19 – Слайд 1

 
Рисунок 2.20 – Слайд 2
 
Рисунок 2.21 – Слайд 3

 
Рисунок 2.22 – Слайд 4
 
Рисунок 2.23 – Слайд 5

 
Рисунок 2.24 – Слайд 6
 
Рисунок 2.25 – Слайд 7

 
Рисунок 2.26 – Слайд 8
 
Рисунок 2.27 – Слайд 9

 
Рисунок 2.28 – Слайд 10





